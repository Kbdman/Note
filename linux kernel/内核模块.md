# 内核模块
## 注册模块加载与卸载代码
+ module_init(func)     
注册模块加载时要执行的函数，该函数要是一个无参，返回整型的函数，返回负数，表示模块初始化失败，模块将不会被加载到内核中
+ module_exit(func)     
注册模块退出时要执行的函数，没有参数没有返回值，如果一个模块没有注册退出函数，那这个模块将无法卸载，除了rmmod -f

## 加载时指定参数
内核模块内可以定义全局变量，并赋初值
使用module_param宏将变量出测成命令行参数
module_param(变量,类型,权限值)
模块在加载后，在/sys/module/模块名/parameters下生成对应参数的文件

## build
```
obj-m := testmodule.o #指定要编译成内核模块的obj文件
KERNELBUILD :=/lib/modules/$(shell uname -r)/build
all:
	make -C $(KERNELBUILD) M=$(shell pwd) modules
clean:
	rm -rf *.o *.ko *.mod.c .*.cmd *.markers *.order *.symvers .tmp_versions
```
调用linux的makefile来构建内核模块

如果是多个obj构成一个模块，以如下方式指定obj-m
```
obj-m := startstop.o
startstop-objs := start.o stop.o
```
将start.o stop.o组装成一个startstop.o,然后将startstop.o生成一个module
obj-m可以+=多个.o，每个.o都将生成一个module

## 安装卸载模块
+ insmod modname [paramname=value]   
安装模块,可以指定参数
+ rmmod     
卸载模块
+ modprobe      
安装或者卸载，具体看参数

## 设备版本号
设备版本号分为主版本号，和次版本号
主版本号标识了管理设备的驱动，次版本号用于驱动来区分具体的设备

## 字设备的大致逻辑
1. 创建一个file_operation实例
2. 填充file_operation实例的各种处理函数
3. 试用register_chrdev(unsigned int major, const char *name, struct file_operations *fops)来注册设备

register_chrdev的参数：
+ major     
主版本号，不能和其他的驱动冲突，可以传0，让系统自动生成，通过返回值返回
+ name      
设备的名称，注册的设备将在/proc/device中出现
+ fops      
设备操作的处理函数

4.在卸载时unregister_chrdev解除设备的注册

## proc文件系统逻辑
1. 通过 create_proc_entry创建一个proc文件对象
2. 通过上面的返回的文件对象设置该文件的读写操作处理函数
3. 卸载时使用remove_proc_entry移除创建的proc文件
