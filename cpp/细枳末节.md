## int的长度
无论在linux下还是windows下，都是4字节

## 类对象的构造过程
### 通俗说法
如果有父类，先按照顺序构造父类，如果有成员对象需要构造，按照声明顺序构造成员。最后构造自身

### 从生成的代码来看
类的构造函数生成的代码中，首先按顺序调用基类的构造函数，然后根据顺序调用成员的构造函数。在这结束后才是自身构造函数中代码生成的代码

### 内存布局

由上往下地址递增
#### 有基类的情况
```
基类对象0
基类对象1
...
成员变量0
成员变量1
...
```
当有多个基类，而其中第一个基类没有虚函数，而后面的基类有虚函数时，构造对象时会有调整对象的位置，使某个有虚函数的基类在对象开始的位置构建

#### 无基类的对象
```
[虚函数表指针]
成员变量0
成员变量1
...
```
### 虚函数表指针的赋值
当前对象虚函数表指针的赋值在基类对象的构造函数完成后进行。所以基类函数在构造函数中无法调用派生类的重写的虚函数.
在调试时发现，似乎在构造/析构函数内对于虚函数，都是直接调用，没有通过虚函数表指针


### x64的调用约定
在Windows下，前四个参数，rcx,rdx,r8,r9,后面的参数通过栈传播，越靠前的参数在栈上的位置越低，调用者为寄存器传递的参数准备栈空间
在Linux下，前6个参数通过，rdi,rsi,rdx,rcx,r8,r9传递，后面的参数通过栈传递，被调用者为寄存器传递的参数准备栈空间
>为什么都用寄存器传递参数了，为什么还要准备栈空间？因为被调用的函数可能还需要调用函数，这样就需要有位置保存之前传的参数

### switch代码生成
+ 连续判断风格      
生成像是多个if的代码，当分支代码少时通常生成
+ 以case值或者其计算值作为索引的跳转表      
将分支代码的地址保存在一个全局的跳转表中，switch生成代码以case值或者其计算值作为索引查跳转表，进行跳转
+ 索引表+跳转表
建立case值到跳转表索引值得索引表，和跳转表，，switch生成代码以case值或者其计算值查索引表，以索引值查跳转表进行跳转。常由多case对一个分支得代码生成


### crt
c/c++的程序的入口往往不一定就是main函数，而是运行时库，编译时与运行时库连接

运行时库主要的功能可能包括，分割字符串参数，准备环境变量，初始化全局变量，mayby tls
